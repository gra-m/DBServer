<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GenericIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DBServer</a> &gt; <a href="index.source.html" class="el_package">fun.madeby.generic</a> &gt; <span class="el_source">GenericIndex.java</span></div><h1>GenericIndex.java</h1><pre class="source lang-java linenums">package fun.madeby.generic;

import fun.madeby.exceptions.DBException;
import fun.madeby.util.LoggerSetUp;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;

/**
 * Created by Gra_m on 2022 06 27
 */

public final class GenericIndex {
	private Logger LOGGER;

	static{
<span class="fc" id="L21">		genericIndexInstance = new GenericIndex();}</span>

	{
		try {
<span class="fc" id="L25">			LOGGER = LoggerSetUp.setUpLogger(&quot;GenericIndex&quot;);</span>
<span class="nc" id="L26">		} catch (IOException e) {</span>
<span class="nc" id="L27">			e.printStackTrace();</span>
<span class="fc" id="L28">		}</span>
	}

	private static final GenericIndex genericIndexInstance;
	private Schema schema;
	private ConcurrentHashMap&lt;Long, Long&gt; mapRowNumberBytePosition;
<span class="fc" id="L34">	private Long totalNumberOfRows = 0L;</span>
	// Updated String indexedBy[name], CHM&lt;String value, Long rowNum&gt;
	private ConcurrentHashMap&lt;String, ConcurrentHashMap&lt;String, Long&gt;&gt; indexByWithMappedValueAndRowNumber;



<span class="fc" id="L40">	private GenericIndex() {</span>
<span class="fc" id="L41">		this.mapRowNumberBytePosition = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L42">		this.indexByWithMappedValueAndRowNumber = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L43">	}</span>

	public static GenericIndex getInstance() {
<span class="fc" id="L46">		return genericIndexInstance;</span>
	}

	public void initialiseGenericIndexSchema(Schema schema) throws DBException {
<span class="fc" id="L50">		this.schema = schema;</span>
<span class="fc" id="L51">		String indexBy = schema.indexBy;</span>


<span class="fc bfc" id="L54" title="All 2 branches covered.">			if (indexBy == null) {</span>
<span class="fc" id="L55">				throw new DBException(&quot;@GenericIndex/initialiseIndexSchema(Schema) -&gt; Schema's indexBy field null&quot;);</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">			} else if(indexBy.equals(&quot;&quot;)) {</span>
<span class="fc" id="L57">				throw new DBException(&quot;@GenericIndex/initialiseIndexSchema(Schema) -&gt; Schema's indexBy field equals\&quot;\&quot;&quot;);</span>
			}

<span class="fc" id="L60">	}</span>

	//printIndexByValues
	public synchronized void printNameIndex(){
<span class="nc" id="L64">		ConcurrentHashMap&lt;String, Long&gt; retrievedValuesToPrint = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">		if(retrievedValuesToPrint.size() == 0)</span>
<span class="nc" id="L66">			System.out.println(&quot;There is nothing in that Indexes ConcurrentHashMap.&quot;);</span>
<span class="nc" id="L67">		retrievedValuesToPrint.forEach((key, value) -&gt; System.out.println(&quot;@GenericIndex/PrintNameIndex: Lists all values and row Numbers within schema indexBy namespace : &quot; + key + &quot; &quot; + value));</span>
<span class="nc" id="L68">	}</span>


	public synchronized void printIndexByNames(){
<span class="nc bnc" id="L72" title="All 2 branches missed.">		if(this.indexByWithMappedValueAndRowNumber.size() == 0)</span>
<span class="nc" id="L73">			System.out.println(&quot;There are no keys in indexByWithMappedValueAndRowNumber&quot;);</span>
<span class="nc" id="L74">		this.indexByWithMappedValueAndRowNumber.forEach((key, value) -&gt; System.out.println(&quot;@GenericIndex/printIndexByNames() Lists All keys in indexByWithMappedValueAndRowNumber : &quot; + key ));</span>
<span class="nc" id="L75">	}</span>


	public void resetTotalNumberOfRows() {
<span class="fc" id="L79">		this.totalNumberOfRows = 0L;</span>
<span class="fc" id="L80">	}</span>

	public synchronized void add(Long bytePosition) {
<span class="fc" id="L83">		this.mapRowNumberBytePosition.put(totalNumberOfRows, bytePosition);</span>
<span class="fc" id="L84">		totalNumberOfRows++;</span>
<span class="fc" id="L85">	}</span>

	public synchronized void addGenericIndexedValue(String GenericIndexedValue, Long rowIndex) {
		ConcurrentHashMap&lt;String, Long&gt; isExisting;
<span class="fc" id="L89">		ConcurrentHashMap&lt;String, Long&gt; addedNewIndexByValue = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L91" title="All 2 branches covered.">		if (checkExists()) {</span>
<span class="fc" id="L92">			isExisting = getExisting();</span>
<span class="fc" id="L93">			isExisting.put(GenericIndexedValue, rowIndex);</span>
<span class="fc" id="L94">			this.indexByWithMappedValueAndRowNumber.put(this.schema.indexBy, isExisting);</span>
		} else {
<span class="fc" id="L96">				addedNewIndexByValue.put(GenericIndexedValue, rowIndex);</span>
<span class="fc" id="L97">				this.indexByWithMappedValueAndRowNumber.put(this.schema.indexBy, addedNewIndexByValue);</span>
		}
<span class="fc" id="L99">	}</span>

	private boolean checkExists() {
<span class="fc bfc" id="L102" title="All 2 branches covered.">		return indexByWithMappedValueAndRowNumber.containsKey(this.schema.indexBy) ? true : false;</span>
	}

	private ConcurrentHashMap&lt;String, Long&gt; getExisting() {
<span class="fc" id="L106">		return indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>
	}

	//previously hasNameInIndex
	public boolean hasGenericIndexedValueInGenericIndex(final String GenericIndexedValue) {
<span class="fc" id="L111">		ConcurrentHashMap&lt;String, Long&gt; checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">		if (checkValue != null) {</span>
<span class="fc" id="L114">			return checkValue.containsKey(GenericIndexedValue);</span>
		}
<span class="fc" id="L116">		return false;</span>
	}


	public Long getRowNumberByName(final String GenericIndexedValue) {
<span class="fc" id="L121">		ConcurrentHashMap&lt;String, Long&gt; checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>

		try {
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">			if (checkValue != null) {</span>
<span class="fc" id="L125">				return checkValue.getOrDefault(GenericIndexedValue, -1L);</span>
			}
<span class="nc" id="L127">			throw new DBException(&quot;@GenericIndex/getRowNumberByName: found indexed by but returned a null CHashMap&quot;);</span>
<span class="nc" id="L128">		}catch (DBException e) {</span>
<span class="nc" id="L129">			e.printStackTrace();</span>
		}
<span class="nc" id="L131">		return -2L;</span>
	}

	// Not used in Index so not here
	/*public void remove(Long rowIndex, Object existingRowNumberObject, Class aClass) {
		this.mapRowNumberBytePosition.remove(rowIndex);
		this.indexByWithMappedValueAndRowNumber.remove(existingRowNumberObject.getName());
		this.totalNumberOfRows--;
	}*/


	public Long getRowsBytePosition(Long rowNumber) {
<span class="fc" id="L143">		return this.mapRowNumberBytePosition.getOrDefault(rowNumber, -1L);</span>
	}

	public synchronized Long getTotalNumberOfRows() {
<span class="fc" id="L147">		return this.totalNumberOfRows;</span>
	}



	public synchronized void clear() {
<span class="fc" id="L153">		this.totalNumberOfRows = 0L;</span>
<span class="fc" id="L154">		this.mapRowNumberBytePosition.clear();</span>
<span class="fc" id="L155">		this.indexByWithMappedValueAndRowNumber.clear();</span>
<span class="fc" id="L156">	}</span>

	// was getNames()
	public synchronized Collection&lt;String&gt; getGenericIndexedValues() {
<span class="fc" id="L160">		Collection&lt;String&gt; noValuesFound  = new ArrayList&lt;&gt;(0);</span>
<span class="fc" id="L161">		ConcurrentHashMap&lt;String, Long&gt; checkValue = new ConcurrentHashMap&lt;&gt;();</span>
		try {
<span class="fc" id="L163">			 checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>
<span class="nc" id="L164">		} catch (NullPointerException e) {</span>
<span class="nc" id="L165">			e.printStackTrace();</span>
<span class="fc" id="L166">		}</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">		if(checkValue != null)</span>
<span class="fc" id="L168">		return checkValue.keySet();</span>
		else
<span class="fc" id="L170">			return noValuesFound;</span>
	}

	public void removeByFilePosition(Long position) {
		Long rowIndex;
<span class="fc" id="L175">		String GenericIndexedValue = null;</span>
<span class="fc" id="L176">		ConcurrentHashMap&lt;String, Long&gt; cHashMap = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>

<span class="fc bfc" id="L178" title="All 2 branches covered.">		if(mapRowNumberBytePosition.isEmpty()) {</span>
<span class="fc" id="L179">			return;</span>
		}
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">		rowIndex = mapRowNumberBytePosition.search(1, (k, v) -&gt; (Objects.equals(v, position)) ? k : -1);</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">		if (rowIndex != -1L) {</span>
<span class="fc" id="L183">			LOGGER.info(&quot;@GenericIndex/removeFilePosition: &quot; + cHashMap.toString());</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">			GenericIndexedValue = cHashMap.search(1, (k, v) -&gt; Objects.equals(v, rowIndex) ? k : null);</span>
		}

<span class="pc bpc" id="L187" title="1 of 2 branches missed.">		if (GenericIndexedValue != null)</span>
<span class="fc" id="L188">			remove(rowIndex, GenericIndexedValue); // just doing this in same way for now could just pass to remove(rowIndex);</span>
<span class="nc" id="L189">		else throw new RuntimeException(&quot;@GenericIndex/removeByFilePosition(Long): removeByFilePosition - rowIndex &quot; + rowIndex + &quot; was searched for in indexByWithMappedValueAndRowNumber, but was not found in order to be removed&quot;);</span>

<span class="fc" id="L191">	}</span>


	public void remove(Long rowIndex, String GenericIndexedValue) {
<span class="fc" id="L195">		ConcurrentHashMap&lt;String, Long&gt; checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>

<span class="fc" id="L197">		this.mapRowNumberBytePosition.remove(rowIndex);</span>
<span class="fc" id="L198">		this.totalNumberOfRows--;</span>

<span class="pc bpc" id="L200" title="1 of 2 branches missed.">		if(checkValue != null) {</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">			if (GenericIndexedValue != null)</span>
<span class="fc" id="L202">				checkValue.remove(GenericIndexedValue);</span>
		}
<span class="fc" id="L204">	}</span>


	//removes from ByteMap and NameMap (Better names?)
	public void remove(Long rowIndex) {
<span class="nc" id="L209">		this.mapRowNumberBytePosition.remove(rowIndex);</span>
<span class="nc" id="L210">		this.totalNumberOfRows--;</span>

<span class="nc" id="L212">		ConcurrentHashMap&lt;String, Long&gt; checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">		if(checkValue != null) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">			String valueToDelete = checkValue.search(1, (k, v) -&gt; Objects.equals(v, rowIndex) ? k : null);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">			if (valueToDelete != null)</span>
<span class="nc" id="L216">				checkValue.remove(valueToDelete);</span>
		}
<span class="nc" id="L218">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GenericIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DBServer</a> &gt; <a href="index.source.html" class="el_package">fun.madeby.generic</a> &gt; <span class="el_source">GenericIndex.java</span></div><h1>GenericIndex.java</h1><pre class="source lang-java linenums">package fun.madeby.generic;

import fun.madeby.exceptions.DBException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by Gra_m on 2022 06 27
 */

public final class GenericIndex {

	static{
<span class="fc" id="L17">		genericIndexInstance = new GenericIndex();}</span>

	private static final GenericIndex genericIndexInstance;
	private Schema schema;
	private ConcurrentHashMap&lt;Long, Long&gt; mapRowNumberBytePosition;
<span class="fc" id="L22">	private Long totalNumberOfRows = 0L;</span>
	// Updated String indexedBy[name], CHM&lt;String value, Long rowNum&gt;
	private ConcurrentHashMap&lt;String, ConcurrentHashMap&lt;String, Long&gt;&gt; indexByWithMappedValueAndRowNumber;



<span class="fc" id="L28">	private GenericIndex() {</span>
<span class="fc" id="L29">		this.mapRowNumberBytePosition = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L30">		this.indexByWithMappedValueAndRowNumber = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L31">	}</span>

	public static GenericIndex getInstance() {
<span class="fc" id="L34">		return genericIndexInstance;</span>
	}

	public void initialiseGenericIndexSchema(Schema schema) {
<span class="fc" id="L38">		this.schema = schema;</span>
<span class="fc" id="L39">		String indexBy = schema.indexBy;</span>

		try {
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">			if (indexBy == null) {</span>
<span class="nc" id="L43">				throw new DBException(&quot;@GenericIndex/initialiseIndexSchema(Schema) -&gt; Schema's indexBy field found null&quot;);</span>
			}
<span class="nc" id="L45">		}catch (DBException e) {</span>
<span class="nc" id="L46">			e.printStackTrace();</span>
<span class="fc" id="L47">		}</span>
<span class="fc" id="L48">	}</span>

	//printIndexByValues
	public synchronized void printNameIndex(){
<span class="nc" id="L52">		ConcurrentHashMap&lt;String, Long&gt; retrievedValuesToPrint = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">		if(retrievedValuesToPrint.size() == 0)</span>
<span class="nc" id="L54">			System.out.println(&quot;There is nothing in that Indexes ConcurrentHashMap.&quot;);</span>
<span class="nc" id="L55">		retrievedValuesToPrint.forEach((key, value) -&gt; System.out.println(&quot;@GenericIndex/PrintNameIndex: Lists all values and row Numbers within schema indexBy namespace : &quot; + key + &quot; &quot; + value));</span>
<span class="nc" id="L56">	}</span>


	public synchronized void printIndexByNames(){
<span class="nc bnc" id="L60" title="All 2 branches missed.">		if(this.indexByWithMappedValueAndRowNumber.size() == 0)</span>
<span class="nc" id="L61">			System.out.println(&quot;There are no keys in indexByWithMappedValueAndRowNumber&quot;);</span>
<span class="nc" id="L62">		this.indexByWithMappedValueAndRowNumber.forEach((key, value) -&gt; System.out.println(&quot;@GenericIndex/printIndexByNames() Lists All keys in indexByWithMappedValueAndRowNumber : &quot; + key ));</span>
<span class="nc" id="L63">	}</span>


	public void resetTotalNumberOfRows() {
<span class="fc" id="L67">		this.totalNumberOfRows = 0L;</span>
<span class="fc" id="L68">	}</span>

	public synchronized void add(Long bytePosition) {
<span class="fc" id="L71">		this.mapRowNumberBytePosition.put(totalNumberOfRows, bytePosition);</span>
<span class="fc" id="L72">		totalNumberOfRows++;</span>
<span class="fc" id="L73">	}</span>

	public synchronized void addGenericIndexedValue(String GenericIndexedValue, Long rowIndex) {
		ConcurrentHashMap&lt;String, Long&gt; isExisting;
<span class="fc" id="L77">		ConcurrentHashMap&lt;String, Long&gt; addedNewIndexByValue = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L79" title="All 2 branches covered.">		if (checkExists()) {</span>
<span class="fc" id="L80">			isExisting = getExisting();</span>
<span class="fc" id="L81">			isExisting.put(GenericIndexedValue, rowIndex);</span>
<span class="fc" id="L82">			this.indexByWithMappedValueAndRowNumber.put(this.schema.indexBy, isExisting);</span>
		} else {
<span class="fc" id="L84">				addedNewIndexByValue.put(GenericIndexedValue, rowIndex);</span>
<span class="fc" id="L85">				this.indexByWithMappedValueAndRowNumber.put(this.schema.indexBy, addedNewIndexByValue);</span>
		}
<span class="fc" id="L87">	}</span>

	private boolean checkExists() {
<span class="fc bfc" id="L90" title="All 2 branches covered.">		return indexByWithMappedValueAndRowNumber.containsKey(this.schema.indexBy) ? true : false;</span>
	}

	private ConcurrentHashMap&lt;String, Long&gt; getExisting() {
<span class="fc" id="L94">		return indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>
	}

	//previously hasNameInIndex
	public boolean hasGenericIndexedValueInGenericIndex(final String GenericIndexedValue) {
<span class="fc" id="L99">		ConcurrentHashMap&lt;String, Long&gt; checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">		if (checkValue != null) {</span>
<span class="fc" id="L102">			return checkValue.containsKey(GenericIndexedValue);</span>
		}
<span class="fc" id="L104">		return false;</span>
	}


	public Long getRowNumberByName(final String GenericIndexedValue) {
<span class="fc" id="L109">		ConcurrentHashMap&lt;String, Long&gt; checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>

		try {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">			if (checkValue != null) {</span>
<span class="fc" id="L113">				return checkValue.getOrDefault(GenericIndexedValue, -1L);</span>
			}
<span class="nc" id="L115">			throw new DBException(&quot;@GenericIndex/getRowNumberByName: found indexed by but returned a null CHashMap&quot;);</span>
<span class="nc" id="L116">		}catch (DBException e) {</span>
<span class="nc" id="L117">			e.printStackTrace();</span>
		}
<span class="nc" id="L119">		return -2L;</span>
	}

	// Not used in Index so not here
	/*public void remove(Long rowIndex, Object existingRowNumberObject, Class aClass) {
		this.mapRowNumberBytePosition.remove(rowIndex);
		this.indexByWithMappedValueAndRowNumber.remove(existingRowNumberObject.getName());
		this.totalNumberOfRows--;
	}*/


	public Long getRowsBytePosition(Long rowNumber) {
<span class="fc" id="L131">		return this.mapRowNumberBytePosition.getOrDefault(rowNumber, -1L);</span>
	}

	public synchronized Long getTotalNumberOfRows() {
<span class="fc" id="L135">		return this.totalNumberOfRows;</span>
	}



	public synchronized void clear() {
<span class="fc" id="L141">		this.totalNumberOfRows = 0L;</span>
<span class="fc" id="L142">		this.mapRowNumberBytePosition.clear();</span>
<span class="fc" id="L143">		this.indexByWithMappedValueAndRowNumber.clear();</span>
<span class="fc" id="L144">	}</span>

	// was getNames()
	public synchronized Collection&lt;String&gt; getGenericIndexedValues() {
<span class="fc" id="L148">		Collection&lt;String&gt; noValuesFound  = new ArrayList&lt;&gt;(0);</span>
<span class="fc" id="L149">		ConcurrentHashMap&lt;String, Long&gt; checkValue = new ConcurrentHashMap&lt;&gt;();</span>
		try {
<span class="fc" id="L151">			 checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>
<span class="nc" id="L152">		} catch (NullPointerException e) {</span>
<span class="nc" id="L153">			e.printStackTrace();</span>
<span class="fc" id="L154">		}</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">		if(checkValue != null)</span>
<span class="fc" id="L156">		return checkValue.keySet();</span>
		else
<span class="fc" id="L158">			return noValuesFound;</span>
	}

	public void removeByFilePosition(Long position) {
		Long rowIndex;
<span class="fc" id="L163">		String GenericIndexedValue = null;</span>
<span class="fc" id="L164">		ConcurrentHashMap&lt;String, Long&gt; cHashMap = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">		if(mapRowNumberBytePosition.isEmpty()) {</span>
<span class="fc" id="L167">			return;</span>
		}
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">		rowIndex = mapRowNumberBytePosition.search(1, (k, v) -&gt; (Objects.equals(v, position)) ? k : -1);</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">		if (rowIndex != -1L) {</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">			GenericIndexedValue = cHashMap.search(1, (k, v) -&gt; Objects.equals(v, rowIndex) ? k : null);</span>
		}

<span class="pc bpc" id="L174" title="1 of 2 branches missed.">		if (GenericIndexedValue != null)</span>
<span class="fc" id="L175">			remove(rowIndex, GenericIndexedValue); // just doing this in same way for now could just pass to remove(rowIndex);</span>
<span class="nc" id="L176">		else throw new RuntimeException(&quot;INDEX: removeByFilePosition - rowIndex &quot; + rowIndex + &quot; was searched for in indexByWithMappedValueAndRowNumber, but was not found in order to be removed&quot;);</span>

<span class="fc" id="L178">	}</span>


	public void remove(Long rowIndex, String GenericIndexedValue) {
<span class="fc" id="L182">		ConcurrentHashMap&lt;String, Long&gt; checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>

<span class="fc" id="L184">		this.mapRowNumberBytePosition.remove(rowIndex);</span>
<span class="fc" id="L185">		this.totalNumberOfRows--;</span>

<span class="pc bpc" id="L187" title="1 of 2 branches missed.">		if(checkValue != null) {</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">			if (GenericIndexedValue != null)</span>
<span class="fc" id="L189">				checkValue.remove(GenericIndexedValue);</span>
		}
<span class="fc" id="L191">	}</span>


	//removes from ByteMap and NameMap (Better names?)
	public void remove(Long rowIndex) {
<span class="nc" id="L196">		this.mapRowNumberBytePosition.remove(rowIndex);</span>
<span class="nc" id="L197">		this.totalNumberOfRows--;</span>

<span class="nc" id="L199">		ConcurrentHashMap&lt;String, Long&gt; checkValue = this.indexByWithMappedValueAndRowNumber.get(this.schema.indexBy);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">		if(checkValue != null) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">			String valueToDelete = checkValue.search(1, (k, v) -&gt; Objects.equals(v, rowIndex) ? k : null);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">			if (valueToDelete != null)</span>
<span class="nc" id="L203">				checkValue.remove(valueToDelete);</span>
		}
<span class="nc" id="L205">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GenericBaseFileHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DBServer</a> &gt; <a href="index.source.html" class="el_package">fun.madeby.generic</a> &gt; <span class="el_source">GenericBaseFileHandler.java</span></div><h1>GenericBaseFileHandler.java</h1><pre class="source lang-java linenums">package fun.madeby.generic;

import fun.madeby.DataHandlerGeneric;
import fun.madeby.exceptions.DBException;
import fun.madeby.util.DebugInfo;
import fun.madeby.util.DebugRowInfo;
import fun.madeby.util.LoggerSetUp;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.logging.Logger;

/**
 * Created by Gra_m on 2022 06 30
 */

public class GenericBaseFileHandler implements DataHandlerGeneric {
	RandomAccessFile dbFile;
	String dbFileName;
<span class="fc" id="L26">	private final String VERSION = &quot;0.1&quot;;</span>
	private static final int START_OF_FILE = 0;
	private static final int HEADER_INFO_SPACE = 100;
<span class="fc" id="L29">	final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span>
<span class="fc" id="L30">	final Lock readLock = readWriteLock.readLock();</span>
<span class="fc" id="L31">	final Lock writeLock = readWriteLock.writeLock();</span>
<span class="fc" id="L32">	protected final int LONG_LENGTH_IN_BYTES = 8;</span>
<span class="fc" id="L33">	protected final int INTEGER_LENGTH_IN_BYTES = 4;</span>
<span class="fc" id="L34">	protected final int BOOLEAN_LENGTH_IN_BYTES = 1;</span>
	protected Schema schema;
	protected Class aClass;
	Logger LOGGER;

	{
		try {
<span class="fc" id="L41">			LOGGER = LoggerSetUp.setUpLogger(&quot;BaseFileHandler/FH&quot;);</span>
<span class="nc" id="L42">		} catch (IOException e) {</span>
<span class="nc" id="L43">			e.printStackTrace();</span>
<span class="fc" id="L44">		}</span>
	}


<span class="fc" id="L48">	public GenericBaseFileHandler(RandomAccessFile randomAccessFile, final String fileName) {</span>
<span class="fc" id="L49">		this.dbFile = randomAccessFile;</span>
<span class="fc" id="L50">		this.dbFileName = fileName;</span>
<span class="fc" id="L51">	}</span>


<span class="fc" id="L54">	public GenericBaseFileHandler(final String fileName) throws FileNotFoundException, DBException {</span>
<span class="fc" id="L55">		this.dbFile = new RandomAccessFile(fileName, &quot;rw&quot;);</span>
<span class="fc" id="L56">		this.dbFileName = fileName;</span>
<span class="fc" id="L57">		writeVersionInfoIfNewFile();</span>
<span class="fc" id="L58">	}</span>

	public void setSchema(Schema schema) {
<span class="fc" id="L61">		this.schema = schema;</span>
<span class="fc" id="L62">	}</span>

	public void setAClass(Class aClass) {
<span class="fc" id="L65">		this.aClass = aClass;</span>
<span class="fc" id="L66">	}</span>


	public void writeVersionInfoIfNewFile() {
		try {
<span class="fc bfc" id="L71" title="All 2 branches covered.">			if (dbFile.length() == 0) {</span>
<span class="fc" id="L72">				this.setDBVersion();</span>
			} else {
<span class="fc" id="L74">				LOGGER.finest(&quot;@BFH writeVersionInfoIfNewFile() and dbFile.length() &gt; 0 DBVersion is: &quot; + VERSION);</span>
			}

<span class="fc" id="L77">		} catch (IOException e) {</span>
<span class="fc" id="L78">			e.printStackTrace();</span>
<span class="fc" id="L79">		}</span>
<span class="fc" id="L80">	}</span>


	@Override
	public Boolean commit(Collection&lt;Long&gt; newRowsBytePosition, Collection&lt;Long&gt; deletedRowsBytePosition) {
<span class="fc" id="L85">		writeLock.lock();</span>
		try {
			// commit new Rows
<span class="fc bfc" id="L88" title="All 2 branches covered.">			for (Long position : newRowsBytePosition) {</span>
<span class="fc" id="L89">				this.dbFile.seek(position);</span>
<span class="fc" id="L90">				dbFile.writeBoolean(false); //  !isTemporary</span>
				// re-read the record
<span class="fc" id="L92">				byte[] b = this.readRawRecord(position);</span>
<span class="fc" id="L93">				Object object = readFromByteStream(new DataInputStream(new ByteArrayInputStream(b)));</span>
				// add to index

<span class="fc" id="L96">				GenericIndex.getInstance().add(position); // increments total number of rows</span>
<span class="fc" id="L97">				String genericIndexedValue = (String)object.getClass().getDeclaredField(schema.indexBy).get(object);</span>
<span class="fc" id="L98">				GenericIndex.getInstance().addGenericIndexedValue(genericIndexedValue, GenericIndex.getInstance().getTotalNumberOfRows() - 1); // does not increment total num of rows.</span>
<span class="fc" id="L99">			}</span>

			// commit deletedRows
<span class="fc bfc" id="L102" title="All 2 branches covered.">			for (Long position : deletedRowsBytePosition) {</span>
<span class="fc" id="L103">				this.dbFile.seek(position);</span>
<span class="fc" id="L104">				dbFile.writeBoolean(false); // !isTemporary</span>
<span class="fc" id="L105">				GenericIndex.getInstance().removeByFilePosition(position);</span>
<span class="fc" id="L106">			}</span>
<span class="nc" id="L107">		} catch (IOException | IllegalAccessException | NoSuchFieldException e) {</span>
<span class="nc" id="L108">			e.printStackTrace();</span>
		} finally {
<span class="fc" id="L110">			writeLock.unlock();</span>
		}
<span class="fc" id="L112">		return true;</span>
	}



	public Object readFromByteStream(final DataInputStream stream) throws IOException {
<span class="fc" id="L118">		Object object = null;</span>
		// Get empty object of class passed via reflection, via constructor now as safer.
		try {
<span class="fc" id="L121">			object = Class.forName(this.aClass.getCanonicalName()).getDeclaredConstructor().newInstance();</span>
<span class="nc" id="L122">		} catch (ClassNotFoundException | InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {</span>
<span class="nc" id="L123">			LOGGER.severe(&quot;@GBFileHandler readObjFromByteStream(stream): &quot; + this.aClass.getSimpleName());</span>
<span class="nc" id="L124">			e.printStackTrace();</span>
<span class="fc" id="L125">		}</span>

		try {
<span class="fc bfc" id="L128" title="All 2 branches covered.">		for (SchemaField field: this.schema.schemaFields) {</span>

<span class="pc bpc" id="L130" title="3 of 5 branches missed.">			switch (field.fieldType.toLowerCase()) {</span>
				case &quot;string&quot; -&gt; {
<span class="fc" id="L132">					int fieldLength = stream.readInt();</span>
<span class="fc" id="L133">					byte[] bArray = new byte[fieldLength];</span>
<span class="fc" id="L134">					stream.read(bArray);// IJ always complains about this but XXX below makes genericIndexedValue the length of the String</span>
<span class="fc" id="L135">					String value = new String(bArray);</span>
					//String value = (String.valueOf(stream.read(bArray))); //XXX
<span class="fc" id="L137">					object.getClass()</span>
<span class="fc" id="L138">							.getDeclaredField(field.fieldName)</span>
<span class="fc" id="L139">							.set(object, value);</span>

<span class="fc" id="L141">				}</span>
				case &quot;boolean&quot; -&gt; {
<span class="nc" id="L143">					boolean value = stream.readBoolean();</span>
<span class="nc" id="L144">					object.getClass()</span>
<span class="nc" id="L145">							.getDeclaredField((field.fieldName))</span>
<span class="nc" id="L146">							.set(object, value);</span>

<span class="nc" id="L148">				}</span>
				case &quot;int&quot; -&gt; {
<span class="fc" id="L150">					int value = stream.readInt();</span>
<span class="fc" id="L151">					object.getClass()</span>
<span class="fc" id="L152">							.getDeclaredField(field.fieldName)</span>
<span class="fc" id="L153">							.set(object, value);</span>
<span class="fc" id="L154">				}</span>
				case &quot;long&quot; -&gt; {
<span class="nc" id="L156">					long value = stream.readLong();</span>
<span class="nc" id="L157">					object.getClass()</span>
<span class="nc" id="L158">							.getDeclaredField(field.fieldName)</span>
<span class="nc" id="L159">							.set(object, value);</span>
				}
			}
<span class="fc" id="L162">		}</span>

<span class="nc" id="L164">		} catch (NoSuchFieldException | IllegalAccessException e) {</span>
<span class="nc" id="L165">			LOGGER.info(&quot;@GBFileHandler readObjFromByteStream(stream): &quot; + e.getMessage());</span>
<span class="nc" id="L166">			e.printStackTrace();</span>
<span class="fc" id="L167">		}</span>


<span class="fc" id="L170">		return object;</span>
	}

	@Override
	public Boolean rollback(Collection&lt;Long&gt; newRowsBytePosition, Collection&lt;Long&gt; deletedRowsBytePosition) {
<span class="fc" id="L175">		writeLock.lock();</span>
		try {
			// rollback new Rows
<span class="fc bfc" id="L178" title="All 2 branches covered.">			for (Long position : newRowsBytePosition) {</span>
<span class="fc" id="L179">				this.dbFile.seek(position);</span>
<span class="fc" id="L180">				dbFile.writeBoolean(false); //  !isTemporary</span>
<span class="fc" id="L181">				this.dbFile.seek(position + BOOLEAN_LENGTH_IN_BYTES);</span>
<span class="fc" id="L182">				dbFile.writeBoolean(true); // isDeleted</span>

<span class="fc" id="L184">				GenericIndex.getInstance().removeByFilePosition(position);</span>
<span class="fc" id="L185">			}</span>
			// rollback deletedRows
<span class="fc bfc" id="L187" title="All 2 branches covered.">			for (Long position : deletedRowsBytePosition) {</span>
<span class="fc" id="L188">				this.dbFile.seek(position);</span>
<span class="fc" id="L189">				dbFile.writeBoolean(false); // !isTemporary</span>
<span class="fc" id="L190">				this.dbFile.seek(position + BOOLEAN_LENGTH_IN_BYTES);</span>
<span class="fc" id="L191">				dbFile.writeBoolean(false); // !isDeleted flag</span>

<span class="fc" id="L193">				byte[] b = this.readRawRecord(position);</span>
<span class="fc" id="L194">				Object object = readFromByteStream(new DataInputStream(new ByteArrayInputStream(b)));</span>
<span class="fc" id="L195">				String genericIndexedValue = (String) object.getClass().getDeclaredField(schema.indexBy).get(object);</span>
<span class="fc" id="L196">				GenericIndex.getInstance().addGenericIndexedValue(genericIndexedValue, GenericIndex.getInstance().getTotalNumberOfRows()); // does not increment total num of rows.</span>
<span class="fc" id="L197">				GenericIndex.getInstance().add(position); //</span>
<span class="fc" id="L198">			}</span>
<span class="nc" id="L199">		} catch (IOException | IllegalAccessException | NoSuchFieldException e) {</span>
<span class="nc" id="L200">			e.printStackTrace();</span>
		} finally {
<span class="fc" id="L202">			writeLock.unlock();</span>
		}
<span class="fc" id="L204">		return true;</span>
	}


	public void populateIndex() {
<span class="fc" id="L209">		LOGGER.finest(&quot;@GBFH PopulateIndex()&quot;);</span>
<span class="fc" id="L210">		long rowNum = 0;</span>
<span class="fc" id="L211">		int recordLength = 0;</span>
<span class="fc" id="L212">		long currentPosition = HEADER_INFO_SPACE;</span>
<span class="fc" id="L213">		long deletedRows = 0;</span>
<span class="fc" id="L214">		long temporaryRows = 0;</span>

<span class="pc bpc" id="L216" title="1 of 2 branches missed.">		if (isExistingData()) {</span>
<span class="fc" id="L217">			writeLock.lock();</span>
			try {
<span class="fc" id="L219">				GenericIndex.getInstance().resetTotalNumberOfRows();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">				while (currentPosition &lt; this.dbFile.length()) {</span>
<span class="fc" id="L221">					this.dbFile.seek(currentPosition);</span>
<span class="fc" id="L222">					boolean isTemporary = this.dbFile.readBoolean(); // new read ifTemporary</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">					if (isTemporary)</span>
<span class="nc" id="L224">						++temporaryRows;</span>
<span class="fc" id="L225">					this.dbFile.seek(currentPosition + BOOLEAN_LENGTH_IN_BYTES);</span>
<span class="fc" id="L226">					boolean isDeleted = this.dbFile.readBoolean();</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">					if (!isDeleted) {</span>
<span class="fc" id="L228">						GenericIndex.getInstance().add(currentPosition);</span>
<span class="nc" id="L229">					} else deletedRows++;</span>

<span class="fc" id="L231">					currentPosition += BOOLEAN_LENGTH_IN_BYTES + BOOLEAN_LENGTH_IN_BYTES;</span>
<span class="fc" id="L232">					recordLength = this.dbFile.readInt();</span>
<span class="fc" id="L233">					currentPosition += INTEGER_LENGTH_IN_BYTES;</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">					if (!isDeleted) {</span>
<span class="fc" id="L235">						this.dbFile.seek(currentPosition);</span>
<span class="fc" id="L236">						byte[] byteArrayOfObject = new byte[recordLength];</span>
<span class="fc" id="L237">						dbFile.read(byteArrayOfObject);</span>
<span class="fc" id="L238">						Object retrievedObject = readFromByteStream(new DataInputStream(new ByteArrayInputStream(byteArrayOfObject)));</span>
<span class="fc" id="L239">						String genericIndexedValue = (String) retrievedObject.getClass().getDeclaredField(schema.indexBy).get(retrievedObject);</span>
<span class="fc" id="L240">						GenericIndex.getInstance().addGenericIndexedValue(genericIndexedValue, rowNum++);</span>
					}
<span class="fc" id="L242">					currentPosition += recordLength;</span>
<span class="fc" id="L243">					System.out.printf(&quot;BFH: PopulateIndex(): total rows - %d | total deleted - %d | total - temporary - %d \n&quot;, rowNum, deletedRows, temporaryRows);</span>
<span class="fc" id="L244">				}</span>
<span class="fc" id="L245">			} catch (IOException | NoSuchFieldException | IllegalAccessException e) {</span>
<span class="fc" id="L246">				e.printStackTrace();</span>
			} finally {
<span class="fc" id="L248">				writeLock.unlock();</span>
			}
		}
<span class="fc" id="L251">	}</span>


	public boolean isExistingData() {
		try {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">			if (this.dbFile.length() == 0) {</span>
<span class="nc" id="L257">				System.out.println(&quot;BFH: populateIndex -&gt; isExistingData() no existing data, nothing to index.&quot;);</span>
<span class="nc" id="L258">				return false;</span>
			}
<span class="fc" id="L260">		} catch (IOException e) {</span>
<span class="fc" id="L261">			e.printStackTrace();</span>
<span class="fc" id="L262">		}</span>
<span class="fc" id="L263">		return true;</span>
	}


	/**
	 * Reads the raw record, returns record data without storage information.
	 *
	 * @param rowsBytePosition Not working with index currently, working if passed -1L.
	 * @return empty byte[] if boolean(deleted),  byte[] of row requested beginning with 3 bytes representing the genericIndexedValue
	 * length int.
	 */
	public byte[] readRawRecord(Long rowsBytePosition) {
<span class="fc" id="L275">		byte[] data = null;</span>

<span class="fc" id="L277">		readLock.lock();</span>
		try {
<span class="fc" id="L279">			dbFile.seek(rowsBytePosition);</span>
<span class="fc" id="L280">			boolean isTemporary = dbFile.readBoolean();</span>
<span class="fc" id="L281">			dbFile.seek(rowsBytePosition + BOOLEAN_LENGTH_IN_BYTES);</span>
<span class="fc" id="L282">			boolean isDeleted = dbFile.readBoolean();</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">			if (isTemporary) {</span>
<span class="nc" id="L284">				LOGGER.severe(&quot;@BaseFileHandler readRawRecord(Long rowsBytePosition) attempting to read isTemporary row&quot;);</span>
<span class="nc" id="L285">				return new byte[]{-1};</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">			} else if (isDeleted) {</span>
<span class="nc" id="L287">				LOGGER.severe(&quot;@BaseFileHandler readRawRecord(Long rowsBytePosition) attempting to read isDeleted row&quot;);</span>
<span class="nc" id="L288">				return new byte[]{-1};</span>
			} else {
<span class="fc" id="L290">				dbFile.seek(rowsBytePosition + BOOLEAN_LENGTH_IN_BYTES + BOOLEAN_LENGTH_IN_BYTES); // 2 byte = 2* boolean</span>
<span class="fc" id="L291">				int recordLength = dbFile.readInt();</span>
<span class="fc" id="L292">				dbFile.seek(rowsBytePosition + BOOLEAN_LENGTH_IN_BYTES + BOOLEAN_LENGTH_IN_BYTES + INTEGER_LENGTH_IN_BYTES); // 6 bytes boolean + int</span>
<span class="fc" id="L293">				data = new byte[recordLength];</span>
<span class="fc" id="L294">				this.dbFile.read(data);</span>
			}
<span class="nc" id="L296">		} catch (IOException e) {</span>
<span class="nc" id="L297">			e.printStackTrace();</span>
		} finally {
<span class="fc" id="L299">			readLock.unlock();</span>
		}
<span class="fc" id="L301">		return data;</span>
	}


	public void close() throws IOException {
<span class="fc" id="L306">		this.dbFile.close();</span>
<span class="fc" id="L307">	}</span>

	public Collection&lt;DebugInfo&gt; getCurrentDebugInfoRows() {
<span class="fc" id="L310">		LOGGER.finest(&quot;@BFH getCurrentDebugInfoRows() collecting debugInfo 1Object 2isTemporary 3isDeleted for each row in .db&quot;);</span>
<span class="fc" id="L311">		readLock.lock();</span>
		DataInputStream stream;
		DebugInfo debugInfo;
<span class="fc" id="L314">		ArrayList&lt;DebugInfo&gt; returnArrayList = null;</span>
		try {
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">			if (dbFile.length() == 0)</span>
<span class="nc" id="L317">				return new ArrayList&lt;&gt;();</span>
			else {
				boolean isTemporary;
				boolean isDeleted;
				Object object;
				int recordLength;
<span class="fc" id="L323">				long currentPosition = HEADER_INFO_SPACE;</span>
<span class="fc" id="L324">				returnArrayList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L325">				this.dbFile.seek(currentPosition);</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">				while (currentPosition &lt; this.dbFile.length()) {</span>
<span class="fc" id="L328">					LOGGER.finest(&quot;@BFH getCurrentDebugInfoRows() while loop file length is: &quot; + this.dbFile.length() + &quot; current position is: &quot; + currentPosition);</span>
<span class="fc" id="L329">					isTemporary = dbFile.readBoolean();</span>
<span class="fc" id="L330">					dbFile.seek(currentPosition + BOOLEAN_LENGTH_IN_BYTES);</span>

<span class="fc" id="L332">					isDeleted = dbFile.readBoolean();</span>
<span class="fc" id="L333">					dbFile.seek(currentPosition + BOOLEAN_LENGTH_IN_BYTES + BOOLEAN_LENGTH_IN_BYTES);</span>

<span class="fc" id="L335">					recordLength = dbFile.readInt();</span>
<span class="fc" id="L336">					dbFile.seek(currentPosition + BOOLEAN_LENGTH_IN_BYTES + BOOLEAN_LENGTH_IN_BYTES + INTEGER_LENGTH_IN_BYTES);</span>
<span class="fc" id="L337">					byte[] rowDataOnly = new byte[recordLength];</span>
<span class="fc" id="L338">					dbFile.read(rowDataOnly);</span>
<span class="fc" id="L339">					stream = new DataInputStream(new ByteArrayInputStream(rowDataOnly));</span>
<span class="fc" id="L340">					object = readFromByteStream(stream);</span>

<span class="fc" id="L342">					debugInfo = new DebugRowInfo(object, isTemporary, isDeleted);</span>
<span class="fc" id="L343">					returnArrayList.add(debugInfo);</span>

<span class="fc" id="L345">					currentPosition += recordLength + BOOLEAN_LENGTH_IN_BYTES + BOOLEAN_LENGTH_IN_BYTES + INTEGER_LENGTH_IN_BYTES;</span>
<span class="fc" id="L346">				}</span>
			}
<span class="fc" id="L348">		} catch (IOException e) {</span>
<span class="fc" id="L349">			e.printStackTrace();</span>
		} finally {
<span class="fc" id="L351">			readLock.unlock();</span>
		}

<span class="fc" id="L354">		return returnArrayList;</span>
	}


	public String getDbFileName() {
<span class="fc" id="L359">		return dbFileName;</span>
	}


	public boolean deleteFile() {
<span class="fc" id="L364">		writeLock.lock();</span>
		try {
<span class="fc" id="L366">			this.dbFile.close();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">			if (new File(this.dbFileName).delete()) {</span>
<span class="fc" id="L368">				System.out.println(&quot;File successfully deleted&quot;);</span>
<span class="fc" id="L369">				return true;</span>
			}
<span class="nc" id="L371">		} catch (IOException e) {</span>
<span class="nc" id="L372">			e.printStackTrace();</span>
		} finally {
<span class="fc" id="L374">			writeLock.unlock();</span>
		}

<span class="fc" id="L377">		System.out.println(&quot;File deletion failed&quot;);</span>
<span class="fc" id="L378">		return false;</span>
	}

	private void setDBVersion() {
		try {
<span class="fc" id="L383">			this.dbFile.seek(START_OF_FILE);</span>
<span class="fc" id="L384">			this.dbFile.writeBytes(VERSION);</span>
			//this.dbFile.write(VERSION.getBytes());
<span class="fc" id="L386">			char[] characterFiller = new char[HEADER_INFO_SPACE - VERSION.length()];</span>
<span class="fc" id="L387">			Arrays.fill(characterFiller, ' ');</span>
<span class="fc" id="L388">			this.dbFile.write(new String(characterFiller).getBytes());</span>
<span class="nc" id="L389">		} catch (IOException e) {</span>
<span class="nc" id="L390">			e.printStackTrace();</span>
<span class="fc" id="L391">		}</span>
<span class="fc" id="L392">	}</span>

	public String getDBVersion() {
<span class="fc" id="L395">		readLock.lock();</span>
		try {
<span class="fc" id="L397">			this.dbFile.seek(START_OF_FILE);</span>
<span class="fc" id="L398">			byte[] bytes = new byte[HEADER_INFO_SPACE];</span>
<span class="fc" id="L399">			this.dbFile.read(bytes);</span>
<span class="fc" id="L400">			return new String(bytes).trim();</span>
<span class="nc" id="L401">		} catch (IOException e) {</span>
<span class="nc" id="L402">			e.printStackTrace();</span>
		} finally {
<span class="fc" id="L404">			readLock.unlock();</span>
		}
<span class="nc" id="L406">		return &quot;Read Fail @ getDBVersion&quot;;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>